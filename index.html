<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Temple-ish Run</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#0f1117">
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; height: 100%;
      background: linear-gradient(180deg, #0f1117 0%, #121826 100%);
      color: #e6e9ef; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial;
    }
    #app { position: fixed; inset: 0; }
    canvas { display: block; touch-action: none; }
    .hud {
      position: fixed; top: env(safe-area-inset-top, 0); left: 0; right: 0; height: 64px;
      display: flex; align-items: center; justify-content: space-between; padding: 10px 14px;
      pointer-events: none; gap: 12px;
    }
    .hud .pill {
      background: rgba(0,0,0,0.35); backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.08); border-radius: 999px; padding: 8px 12px;
      font-weight: 700; font-size: 14px; display: flex; align-items: center; gap: 8px;
    }
    .hud .center { margin: 0 auto; pointer-events: none; }
    .hud .right, .hud .left { display: flex; gap: 8px; pointer-events: auto; }
    .btn { cursor: pointer; user-select: none; transition: transform .08s ease; }
    .btn:active { transform: scale(0.95); }
    .overlay {
      position: fixed; inset: 0; display: grid; place-items: center;
      background: radial-gradient(1200px 800px at 50% 100%, rgba(0,0,0,0.5), rgba(0,0,0,0.75)); z-index: 2;
    }
    .card {
      width: min(92vw, 520px); background: rgba(12,14,22,0.75);
      border: 1px solid rgba(255,255,255,0.08); box-shadow: 0 20px 80px rgba(0,0,0,0.5);
      border-radius: 16px; padding: 22px; text-align: center; backdrop-filter: blur(8px);
    }
    .card h1 { margin: 6px 0 0; font-size: 22px; }
    .card p  { margin: 8px 0 16px; opacity: 0.85; }
    .card .row { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; }
    .primary {
      padding: 12px 18px; border-radius: 12px; font-weight: 800; color: #000;
      background: #ffcc00; border: none; cursor: pointer; transition: transform .08s ease, filter .18s ease;
    }
    .primary:active { transform: translateY(1px); filter: brightness(0.95); }
    .small { font-size: 12px; opacity: 0.7; }
    .pow {
      width: 28px; height: 28px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.15);
      background: rgba(0,0,0,0.25); display: grid; place-items: center; font-size: 14px;
    }
    .toast {
      position: fixed; bottom: calc(env(safe-area-inset-bottom, 0) + 18px); left: 50%;
      transform: translateX(-50%); background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1);
      padding: 8px 12px; border-radius: 12px; font-size: 12px; display: none; z-index: 3;
    }
    @media (min-width: 820px) { .card h1 { font-size: 26px; } }
  </style>

  <!-- Three.js (non-module, broad compatibility) -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
</head>
<body>
  <div id="app"></div>

  <!-- HUD -->
  <div class="hud" id="hud" style="display:none">
    <div class="left">
      <div class="pill">üèÅ <span id="dist">0</span> m</div>
      <div class="pill">ü™ô <span id="coins">0</span></div>
    </div>
    <div class="center">
      <div class="pill">Best: <span id="best">0</span></div>
    </div>
    <div class="right">
      <div class="pill"><div class="pow" title="Magnet">üß≤</div><span id="magT" class="small">0</span></div>
      <div class="pill"><div class="pow" title="Shield">üõ°Ô∏è</div><span id="shdT" class="small">0</span></div>
      <div class="pill"><div class="pow" title="Boost">‚ö°</div><span id="bstT" class="small">0</span></div>
      <div class="pill btn" id="pauseBtn" title="Pause">‚è∏Ô∏è</div>
    </div>
  </div>

  <!-- Start Overlay -->
  <div class="overlay" id="start">
    <div class="card">
      <div style="font-size:28px">üèÉ Temple-ish Run</div>
      <h1>Swipe: left/right to change lanes, up to jump, down to slide</h1>
      <p>Collect coins, avoid obstacles, and grab power-ups. Works on touch and keyboard.</p>
      <div class="row" style="margin-bottom: 10px;">
        <button class="primary" id="startBtn">Tap to Start</button>
      </div>
      <div class="small">Keyboard: ‚Üê ‚Üí to change lanes, ‚Üë to jump, ‚Üì to slide, P to pause</div>
    </div>
  </div>

  <!-- Game Over Overlay -->
  <div class="overlay" id="gameover" style="display:none">
    <div class="card">
      <div style="font-size:28px">üí• Game Over</div>
      <h1 id="scoreLine">Score: 0 m ‚Ä¢ Coins: 0</h1>
      <p>Best: <span id="best2">0</span></p>
      <div class="row"><button class="primary" id="retryBtn">Play Again</button></div>
    </div>
  </div>

  <div class="toast" id="toast">Paused</div>

  <script>
  (() => {
    if (!window.THREE || !THREE.WebGLRenderer) { alert('Three.js failed to load.'); return; }

    // ---------- Utils ----------
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const lerp = (a,b,t) => a + (b-a) * t;
    const now = () => performance.now() / 1000;
    function rngMulberry(seed) {
      let t = seed >>> 0;
      return function() {
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ t >>> 15, 1 | t);
        r ^= r + Math.imul(r ^ r >>> 7, 61 | r);
        return ((r ^ r >>> 14) >>> 0) / 4294967296;
      }
    }

    // ---------- Config ----------
    const CONFIG = {
      lanes: [-2.8, 0, 2.8],
      segLen: 14,
      segCount: 36,
      groundWidth: 10,
      laneStripeWidth: 0.1,
      startSpeed: 13.5,
      maxSpeed: 36,
      accel: 0.015,
      gravity: 42,
      jumpVel: 16.5,
      slideTime: 0.6,
      camZ: 10.0,
      camY: 5.2,
      powerupChance: 0.035,
      coinMagnetRadius: 6.0,
      safeStartSegs: 4,     // NEW: obstacle-free runway on start/retry
      audio: false
    };

    const State = { Ready:'ready', Playing:'playing', Paused:'paused', GameOver:'gameover' };

    // ---------- SFX (optional) ----------
    const SFX = (() => {
      if (!CONFIG.audio) return { coin(){}, pow(){}, hit(){}, step(){}, gameover(){} };
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      function beep(freq=880, dur=0.12, type='sine', vol=0.12) {
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.type = type; o.frequency.value = freq; g.gain.value = vol;
        o.connect(g); g.connect(ctx.destination); o.start(); o.stop(ctx.currentTime + dur);
      }
      return { coin(){ beep(1200, 0.08, 'triangle', 0.08); },
               pow(){ beep(500, 0.16, 'square', 0.08); },
               hit(){ beep(200, 0.2, 'sawtooth', 0.12); },
               step(){}, gameover(){ beep(160, 0.35, 'sawtooth', 0.12); } };
    })();

    // ---------- Input ----------
    class Input {
      constructor(el) {
        this.el = el; this.resetSwipe();
        this.onLeft = null; this.onRight = null; this.onUp = null; this.onDown = null; this.onPause = null;

        el.addEventListener('touchstart', (e) => this.tstart(e), {passive: false});
        el.addEventListener('touchmove',  (e) => this.tmove(e),  {passive: false});
        el.addEventListener('touchend',   (e) => this.tend(e),   {passive: false});
        el.addEventListener('touchcancel',(e) => this.tend(e),   {passive: false});

        el.addEventListener('mousedown', (e) => { this.mdown = true; this.sx = e.clientX; this.sy = e.clientY; this.st = now(); e.preventDefault(); });
        el.addEventListener('mousemove', (e) => { if (this.mdown) { this.cx = e.clientX; this.cy = e.clientY; e.preventDefault(); } });
        el.addEventListener('mouseup',   (e) => { if (!this.mdown) return; this.mdown=false; this.handleSwipe(this.cx-this.sx, this.cy-this.sy, now()-this.st); e.preventDefault(); });

        window.addEventListener('keydown', (e) => {
          if (e.repeat) return;
          const k = e.key.toLowerCase();
          if (k === 'arrowleft' || k === 'a') this.onLeft?.();
          else if (k === 'arrowright' || k === 'd') this.onRight?.();
          else if (k === 'arrowup' || k === 'w' || k === ' ') this.onUp?.();
          else if (k === 'arrowdown' || k === 's') this.onDown?.();
          else if (k === 'p' || k === 'escape') this.onPause?.();
        });
      }
      resetSwipe(){ this.sx=this.sy=this.cx=this.cy=0; this.st=0; this.mdown=false; }
      tstart(e){ const t=e.changedTouches[0]; this.sx=t.clientX; this.sy=t.clientY; this.cx=this.sx; this.cy=this.sy; this.st=now(); e.preventDefault(); }
      tmove(e){ const t=e.changedTouches[0]; this.cx=t.clientX; this.cy=t.clientY; e.preventDefault(); }
      tend(e){ const t=e.changedTouches[0]; this.handleSwipe(t.clientX-this.sx, t.clientY-this.sy, now()-this.st); this.resetSwipe(); e.preventDefault(); }
      handleSwipe(dx,dy,dt){
        const absX=Math.abs(dx), absY=Math.abs(dy), thresh=30;
        if (absX < thresh && absY < thresh) return;
        if (absX > absY) (dx>0?this.onRight:this.onLeft)?.();
        else (dy<0?this.onUp:this.onDown)?.();
      }
    }

    // ---------- Game ----------
    class Game {
      constructor(container) {
        this.container = container;
        this.state = State.Ready;
        this.rng = rngMulberry(Math.floor(Math.random()*1e9));
        this.totalTime = 0;
        this.distance = 0;
        this.speed = CONFIG.startSpeed;
        this.baseSpeed = CONFIG.startSpeed;
        this.coins = 0;
        this.best = Number(localStorage.getItem('bestRunScore')||0);

        this.magnetT = 0; this.shieldT = 0; this.boostT = 0;

        // THREE
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x0e1322, 0.018);
        this.clock = new THREE.Clock();
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: 'high-performance' });
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        if ('outputColorSpace' in this.renderer) this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.container.appendChild(this.renderer.domElement);

        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
        this.camera.position.set(0, CONFIG.camY, CONFIG.camZ);
        this._cameraLook = new THREE.Vector3(0,1.2,0);

        // Lights
        const hem = new THREE.HemisphereLight(0xaadfff, 0x223344, 0.7);
        const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5,10,8);
        this.scene.add(hem, dir);

        // Groups
        this.trackGroup = new THREE.Group(); this.scene.add(this.trackGroup);

        // Player
        this.playerY = 0.9;
        this.player = this.createPlayer();
        this.scene.add(this.player.group);
        this.laneIndex = 1; this.targetX = CONFIG.lanes[this.laneIndex];
        this.verticalVel = 0; this.onGround = true; this.sliding = false; this.slideTimer = 0;

        // Track
        this.segments = []; this.frontZ = -CONFIG.segLen; this.globalSegmentIndex = 0;
        this.activeObstacles = []; this.activeCoins = []; this.activePowerups = [];
        this.buildInitialSegments();

        // HUD
        this.$hud = document.getElementById('hud');
        this.$dist = document.getElementById('dist');
        this.$coins = document.getElementById('coins');
        this.$best = document.getElementById('best'); this.$best.textContent = this.best.toFixed(0);
        this.$magT = document.getElementById('magT'); this.$shdT = document.getElementById('shdT'); this.$bstT = document.getElementById('bstT');
        this.$toast = document.getElementById('toast');

        // Overlays
        this.$start = document.getElementById('start');
        this.$gameover = document.getElementById('gameover');
        this.$scoreLine = document.getElementById('scoreLine');
        this.$best2 = document.getElementById('best2');

        // Input
        this.input = new Input(this.renderer.domElement);
        this.input.onLeft = () => this.changeLane(-1);
        this.input.onRight = () => this.changeLane(+1);
        this.input.onUp = () => this.tryJump();
        this.input.onDown = () => this.trySlide();
        this.input.onPause = () => this.togglePause();
        document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());

        // Buttons
        document.getElementById('startBtn').addEventListener('click', () => this.start());
        document.getElementById('retryBtn').addEventListener('click', () => this.restart());

        // Resize
        window.addEventListener('resize', () => this.onResize());
        this.onResize();

        // Animate
        this.renderer.setAnimationLoop(() => this.loop());
      }

      onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
      }

      createPlayer() {
        const group = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({ color: 0x44ddff, metalness: 0.1, roughness: 0.5 });
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.6, 0.8), mat);
        body.position.y = this.playerY; group.add(body);

        const head = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.7, 0.7), new THREE.MeshStandardMaterial({color: 0xffffff}));
        head.position.set(0, this.playerY + 1.3, 0); group.add(head);

        return { group, body, head, width: 0.9, height: 1.9, depth: 0.8 };
      }

      buildInitialSegments() {
        for (let i = 0; i < CONFIG.segCount; i++) {
          const seg = this.createSegment();
          seg.group.position.z = -i * CONFIG.segLen;
          seg.index = this.globalSegmentIndex++;
          this.populateSegment(seg);
          this.segments.push(seg);
          this.trackGroup.add(seg.group);
          this.frontZ = -CONFIG.segCount * CONFIG.segLen;
        }
      }

      createSegment() {
        const group = new THREE.Group();

        const gMat = new THREE.MeshStandardMaterial({ color: 0x2e3445, metalness: 0.0, roughness: 0.95 });
        const ground = new THREE.Mesh(new THREE.BoxGeometry(CONFIG.groundWidth, 0.5, CONFIG.segLen), gMat);
        ground.position.y = -0.25; group.add(ground);

        const stripeGeo = new THREE.BoxGeometry(CONFIG.laneStripeWidth, 0.02, CONFIG.segLen);
        const stripeMat = new THREE.MeshStandardMaterial({ color: 0xf6d365, emissive: 0x000000, roughness: 0.8 });
        const s1 = new THREE.Mesh(stripeGeo, stripeMat); s1.position.set((CONFIG.lanes[0]+CONFIG.lanes[1]) * 0.5, 0.01, 0);
        const s2 = new THREE.Mesh(stripeGeo, stripeMat); s2.position.set((CONFIG.lanes[1]+CONFIG.lanes[2]) * 0.5, 0.01, 0);
        group.add(s1, s2);

        group.userData.content = { obstacles: [], coins: [], powerups: [] };
        return { group };
      }

      populateSegment(seg) {
        const content = seg.group.userData.content;
        for (const arrName of ['obstacles','coins','powerups']) {
          for (const obj of content[arrName]) seg.group.remove(obj.mesh || obj);
          content[arrName].length = 0;
        }

        const localRng = rngMulberry(seg.index * 1337 + Math.floor(this.best + this.totalTime*1000));
        const zWithin = () => (localRng()*(CONFIG.segLen*0.6) - CONFIG.segLen*0.3);

        const addLow = (lane,z) => {
          const w=1.6,h=1.0,d=1.2;
          const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({color:0xe15e32, roughness:0.7}));
          mesh.position.set(CONFIG.lanes[lane], h*0.5-0.02, z); seg.group.add(mesh);
          const o={type:'low', w:w*0.5, h, d:d*0.5, mesh}; content.obstacles.push(o); this.activeObstacles.push(o);
        };
        const addHigh = (lane,z) => {
          const w=1.6,h=0.25,d=1.0,y=1.2;
          const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({color:0xff9933, roughness:0.6}));
          mesh.position.set(CONFIG.lanes[lane], y, z); seg.group.add(mesh);
          const o={type:'high', w:w*0.5, h, d:d*0.5, y, mesh}; content.obstacles.push(o); this.activeObstacles.push(o);
        };
        const addWallGap = (gapLane,z) => {
          const mat = new THREE.MeshStandardMaterial({color:0x8844aa, roughness:0.7});
          for (let lane=0; lane<3; lane++){
            if (lane === gapLane) continue;
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1.4, 1.3), mat);
            mesh.position.set(CONFIG.lanes[lane], 0.7, z); seg.group.add(mesh);
            const o={type:'wall', w:0.8, h:1.4, d:0.65, y:0.7, mesh}; content.obstacles.push(o); this.activeObstacles.push(o);
          }
        };
        const addSweeper = (z) => {
          const w=1.2,h=1.1,d=1.0;
          const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({color:0x00bcd4, roughness:0.35}));
          mesh.position.set(0, h*0.5, z); mesh.userData.phase = localRng()*Math.PI*2; seg.group.add(mesh);
          const o={type:'sweeper', w:w*0.5, h, d:d*0.5, mesh, updater:(t)=>{ mesh.position.x = Math.sin(t*1.4 + mesh.userData.phase)*2.8; }};
          content.obstacles.push(o); this.activeObstacles.push(o);
        };

        // NEW: Safe runway ‚Äî no obstacles on first few segments
        const safe = seg.index < CONFIG.safeStartSegs;

        if (!safe) {
          const r = localRng();
          if (r < 0.25) { /* empty */ }
          else if (r < 0.50) addLow(Math.floor(localRng()*3), zWithin());
          else if (r < 0.66) { const gap=Math.floor(localRng()*3); for (let lane=0; lane<3; lane++) if (lane!==gap) addLow(lane, zWithin()); }
          else if (r < 0.80) addHigh(Math.floor(localRng()*3), zWithin());
          else if (r < 0.93) addSweeper(zWithin());
          else addWallGap(Math.floor(localRng()*3), zWithin());
        }

        // Coins (still spawn during safe start)
        const coinPatterns = ['line','line','arc','vee'];
        const cp = coinPatterns[Math.floor(localRng()*coinPatterns.length)];
        const coinLane = Math.floor(localRng()*3);
        const coinCount = 5 + Math.floor(localRng()*4);
        const baseZ = (localRng()*0.8 - 0.9) * CONFIG.segLen;
        for (let i=0;i<coinCount;i++) {
          let x = CONFIG.lanes[coinLane], y = 1.0, z = baseZ + i* (CONFIG.segLen/coinCount);
          if (cp==='arc') { const t = (i/(coinCount-1))*Math.PI; y = 0.8 + Math.sin(t) * 0.8; }
          else if (cp==='vee') { const t = (i/(coinCount-1))*2 - 1; x += t * 1.2; }
          const coin = this.makeCoin(x, y, z); seg.group.add(coin);
          content.coins.push(coin); this.activeCoins.push(coin);
        }

        // Powerup
        if (!safe && localRng() < CONFIG.powerupChance) {
          const p = localRng(), kind = p<0.4?'magnet':p<0.75?'shield':'boost';
          const x = CONFIG.lanes[Math.floor(localRng()*3)]; const y = 1.0 + localRng()*0.3; const z = (localRng()*0.8 - 0.4) * CONFIG.segLen;
          const pu = this.makePowerup(kind, x, y, z); seg.group.add(pu.mesh);
          seg.group.userData.content.powerups.push(pu); this.activePowerups.push(pu);
        }
      }

      makeCoin(x,y,z) {
        const mat = new THREE.MeshStandardMaterial({color: 0xffd700, emissive: 0x221100, metalness: 0.5, roughness: 0.3});
        const coin = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.08, 16), mat);
        coin.rotation.z = Math.PI*0.5; coin.position.set(x,y,z); coin.userData.isCoin = true;
        return coin;
      }
      makePowerup(kind,x,y,z) {
        let color=0xffffff;
        if (kind==='magnet') color=0x00e0ff;
        if (kind==='shield') color=0x7effa5;
        if (kind==='boost')  color=0xff66aa;
        const mesh = new THREE.Mesh(new THREE.TorusKnotGeometry(0.34, 0.12, 64, 8, 2, 3),
                      new THREE.MeshStandardMaterial({color, roughness:0.35, metalness:0.4}));
        mesh.position.set(x,y,z);
        mesh.userData = { type:'powerup', kind, baseY: y, spin: (Math.random()*0.6+0.4) * (Math.random()<0.5?1:-1) };
        return { kind, mesh };
      }

      changeLane(delta) {
        if (this.state !== State.Playing) return;
        const newIndex = clamp(this.laneIndex + delta, 0, 2);
        if (newIndex !== this.laneIndex) { this.laneIndex = newIndex; this.targetX = CONFIG.lanes[newIndex]; }
      }
      tryJump() {
        if (this.state !== State.Playing) return;
        if (this.onGround && !this.sliding) { this.verticalVel = CONFIG.jumpVel * (this.boostT>0 ? 1.15 : 1.0); this.onGround = false; }
      }
      trySlide() {
        if (this.state !== State.Playing) return;
        if (this.onGround && !this.sliding) { this.sliding = true; this.slideTimer = CONFIG.slideTime; }
      }
      togglePause() {
        if (this.state === State.Playing) { this.state = State.Paused; this.showToast('Paused'); }
        else if (this.state === State.Paused) { this.state = State.Playing; this.hideToast(); this.clock.getDelta(); }
      }
      showToast(text){ const t=document.getElementById('toast'); t.textContent=text; t.style.display='block'; }
      hideToast(){ document.getElementById('toast').style.display='none'; }

      start() {
        this.$start.style.display = 'none';
        this.$hud.style.display = 'flex';
        this.state = State.Playing;
        this.clock.getDelta();
      }

      restart() {
        // Clear content
        for (const seg of this.segments) {
          const c = seg.group.userData.content;
          for (const arrName of ['obstacles','coins','powerups']) {
            for (const obj of c[arrName]) seg.group.remove(obj.mesh || obj);
            c[arrName].length = 0;
          }
          seg.group.position.z = 0;
        }
        this.activeObstacles.length = 0;
        this.activeCoins.length = 0;
        this.activePowerups.length = 0;

        // Reset track with safe runway
        this.frontZ = -CONFIG.segLen; this.globalSegmentIndex = 0;
        for (let i=0; i<this.segments.length; i++){
          const seg = this.segments[i];
          seg.group.position.z = -i * CONFIG.segLen;
          seg.index = this.globalSegmentIndex++;
          this.populateSegment(seg);
        }
        this.trackGroup.position.z = 0;

        // Reset player/state
        this.laneIndex = 1; this.targetX = CONFIG.lanes[1];
        this.player.group.position.set(this.targetX, 0, 0);
        this.player.body.position.y = this.playerY;
        this.player.body.scale.y = 1.0;
        this.player.head.position.y = this.playerY + 1.3; this.player.head.visible = true;
        this.verticalVel = 0; this.onGround = true; this.sliding = false; this.slideTimer = 0;
        this.distance = 0; this.coins = 0; this.speed = CONFIG.startSpeed; this.baseSpeed = CONFIG.startSpeed;
        this.magnetT = 0; this.shieldT = 0; this.boostT = 0;

        this.$coins.textContent = '0'; this.$dist.textContent = '0';
        this.$gameover.style.display = 'none';
        this.$hud.style.display = 'flex';
        this.state = State.Playing; this.clock.getDelta();
      }

      loop() {
        const dt = this.clock.getDelta();
        if (this.state === State.Playing) this.update(dt);
        this.render();
      }

      update(dt) {
        this.totalTime += dt;

        // Speed progression / boost
        if (this.boostT > 0) {
          this.boostT -= dt;
          this.speed = lerp(this.speed, CONFIG.maxSpeed*1.1, 0.05);
        } else {
          this.speed = clamp(this.speed + CONFIG.accel * dt * 60 * 0.25, CONFIG.startSpeed, CONFIG.maxSpeed);
        }

        // Move world
        this.trackGroup.position.z += this.speed * dt;
        this.distance = Math.max(0, this.trackGroup.position.z|0);
        this.$dist.textContent = String(this.distance);
        this.$coins.textContent = String(this.coins);
        this.$magT.textContent = this.magnetT > 0 ? this.magnetT.toFixed(0) : '0';
        this.$shdT.textContent = this.shieldT > 0 ? this.shieldT.toFixed(0) : '0';
        this.$bstT.textContent = this.boostT > 0 ? this.boostT.toFixed(0) : '0';

        // X lerp
        this.player.group.position.x = lerp(this.player.group.position.x, this.targetX, 0.22);

        // Y physics
        if (!this.onGround) {
          this.verticalVel -= CONFIG.gravity * dt;
          const newY = this.player.body.position.y + this.verticalVel * dt;
          if (newY <= this.playerY) { this.player.body.position.y = this.playerY; this.player.head.position.y = this.playerY + 1.3; this.onGround = true; this.verticalVel = 0; }
          else { this.player.body.position.y = newY; this.player.head.position.y = newY + 1.3; }
        }
        if (this.sliding) {
          this.slideTimer -= dt;
          const t = clamp(this.slideTimer / CONFIG.slideTime, 0, 1);
          const height = 1.6 - (1.0 - t) * 0.8;
          this.player.body.scale.y = height / 1.6; this.player.head.visible = false;
          if (this.slideTimer <= 0) { this.sliding = false; this.player.body.scale.y = 1.0; this.player.head.visible = true; }
        }

        // Recycle segments
        const recycleThreshold = this.camera.position.z + 8;
        const totalSpan = CONFIG.segCount * CONFIG.segLen;
        for (const seg of this.segments) {
          const worldZ = seg.group.position.z + this.trackGroup.position.z;
          if (worldZ > recycleThreshold) {
            seg.group.position.z -= totalSpan;
            seg.index = this.globalSegmentIndex++;
            this.populateSegment(seg);
          }
        }

        // Animate coins/powerups
        const playerWorld = new THREE.Vector3();
        this.player.group.getWorldPosition(playerWorld);
        playerWorld.y = this.player.body.position.y + 0.3;

        for (const coin of this.activeCoins) {
          if (!coin.parent) continue;
          coin.rotation.y += dt * 6;
          if (this.magnetT > 0 || this.boostT > 0) {
            const cpos = new THREE.Vector3();
            coin.getWorldPosition(cpos);
            const dx = playerWorld.x - cpos.x;
            const dy = playerWorld.y - cpos.y;
            const dz = playerWorld.z - cpos.z;
            const dist = Math.hypot(dx,dy,dz);
            if (dist < CONFIG.coinMagnetRadius) {
              const f = 1.0 - dist/CONFIG.coinMagnetRadius;
              coin.position.x += dx * 0.08 * f;
              coin.position.y += (dy + 0.1) * 0.08 * f;
              coin.position.z += dz * 0.08 * f;
            }
          }
        }
        for (const pu of this.activePowerups) {
          const m = pu.mesh; if (!m.parent) continue;
          m.rotation.y += dt * m.userData.spin;
          m.position.y = m.userData.baseY + Math.sin(this.totalTime*2.0) * 0.12;
        }

        // Moving obstacles
        for (const o of this.activeObstacles) if (o.type==='sweeper' && o.mesh.parent) o.updater(this.totalTime);

        // Collisions
        this.handleCollisions(dt, playerWorld);

        // Camera follow
        const targetCamX = this.player.group.position.x * 0.2;
        this.camera.position.x = lerp(this.camera.position.x, targetCamX, 0.05);
        const bob = Math.sin(this.totalTime * (this.onGround? 10 : 2)) * (this.onGround? 0.05 : 0.02);
        this.camera.position.y = lerp(this.camera.position.y, CONFIG.camY + bob, 0.15);
        this.camera.lookAt(this._cameraLook);
      }

      handleCollisions(dt, playerWorld) {
        const pWidth = this.player.width * 0.5;
        const pDepth = this.player.depth * 0.5;
        const pHeight = (this.sliding ? 1.0 : 1.9);
        const pBottom = this.player.body.position.y - 0.0;
        const pTop = pBottom + pHeight;

        const tmp = new THREE.Vector3();

        // Obstacles (use world position for correct Z)
        for (const o of this.activeObstacles) {
          if (!o.mesh.parent) continue;
          o.mesh.getWorldPosition(tmp);
          const dx = Math.abs(playerWorld.x - tmp.x);
          const dz = Math.abs(playerWorld.z - tmp.z);
          if (dz > 2.6) continue;
          const overlapX = dx < (pWidth + o.w - 0.05);
          const overlapZ = dz < (pDepth + o.d - 0.05);
          if (!overlapX || !overlapZ) continue;

          let collide = false;
          if (o.type==='low' || o.type==='sweeper') {
            const oTop = tmp.y + (o.h || 1.0) * 0.5; // FIX: top = y + h/2
            if (pBottom < oTop) collide = true;
          } else if (o.type==='high' || o.type==='wall') {
            const oLo = tmp.y - (o.h*0.5);
            const oHi = tmp.y + (o.h*0.5);
            if (pTop > oLo && pBottom < oHi) collide = true;
          }

          if (collide) {
            if (this.boostT > 0 || this.shieldT > 0) {
              if (this.shieldT > 0 && this.boostT <= 0) this.shieldT = 0;
              o.mesh.parent?.remove(o.mesh); SFX.hit(); continue;
            }
            this.gameOver(); return;
          }
        }

        // Coins (world position)
        for (const coin of this.activeCoins) {
          if (!coin.parent) continue;
          coin.getWorldPosition(tmp);
          if (tmp.z > this.camera.position.z + 4) { coin.parent?.remove(coin); continue; }
          if (Math.abs(tmp.z - playerWorld.z) < 1.2 && Math.abs(tmp.x - playerWorld.x) < 0.7 && Math.abs(tmp.y - playerWorld.y) < 0.9) {
            coin.parent?.remove(coin); this.coins++; SFX.coin();
          }
        }

        // Powerups (world position)
        for (const pu of this.activePowerups) {
          const m = pu.mesh; if (!m.parent) continue;
          m.getWorldPosition(tmp);
          if (tmp.z > this.camera.position.z + 4) { m.parent?.remove(m); continue; }
          if (Math.abs(tmp.z - playerWorld.z) < 1.2 && Math.abs(tmp.x - playerWorld.x) < 1.0 && Math.abs(tmp.y - playerWorld.y) < 1.2) {
            m.parent?.remove(m);
            if (pu.kind==='magnet') this.magnetT = 10;
            else if (pu.kind==='shield') this.shieldT = 8;
            else if (pu.kind==='boost')  this.boostT  = 2.8;
            SFX.pow();
          }
        }

        // Tick down powerups
        this.magnetT = Math.max(0, this.magnetT - dt);
        this.shieldT = Math.max(0, this.shieldT - dt);
      }

      gameOver() {
        if (this.state !== State.Playing) return;
        this.state = State.GameOver; SFX.gameover();
        if (this.distance > this.best) { this.best = this.distance; localStorage.setItem('bestRunScore', String(this.best)); }
        this.$hud.style.display = 'none';
        this.$scoreLine.textContent = `Score: ${this.distance} m ‚Ä¢ Coins: ${this.coins}`;
        this.$best2.textContent = this.best.toFixed(0);
        this.$gameover.style.display = 'grid';
      }

      render() { this.renderer.render(this.scene, this.camera); }
    }

    // ---------- Boot ----------
    const app = new Game(document.getElementById('app'));
    window.__game = app;
  })();
  </script>
</body>
</html>
